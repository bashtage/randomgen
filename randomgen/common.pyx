#!python
from collections import namedtuple
import sys
import warnings

import numpy as np
from numpy.random import SeedSequence

cimport numpy as np
from numpy.random.bit_generator cimport BitGenerator as _BitGenerator

from randomgen._deprecated_value import _DeprecatedValue
from randomgen.seed_sequence import ISeedSequence

ISEED_SEQUENCES = (ISeedSequence, np.random.bit_generator.ISeedSequence)

__all__ = ["interface"]

np.import_array()

interface = namedtuple("interface", ["state_address", "state", "next_uint64",
                                     "next_uint32", "next_double",
                                     "bit_generator"])

cdef bint RANDOMGEN_BIG_ENDIAN = sys.byteorder == "big"
cdef bint RANDOMGEN_LITTLE_ENDIAN = not RANDOMGEN_BIG_ENDIAN

cdef class BitGenerator(_BitGenerator):
    """
    Abstract class for all BitGenerators
    """
    def __init__(self, seed, *, numpy_seed=False, mode=_DeprecatedValue):
        if mode is not _DeprecatedValue:
            msg = ("mode is deprecated and will be removed in a future version. "
                   "Seeding defaults to a numpy.random.SeedSequence instance.")
            if "numpy" in self._supported_modes():
                msg += " Use numpy_seed=True to enforce numpy-compatible seeding."
            warnings.warn(msg, FutureWarning)
        if mode is not _DeprecatedValue and (
                not isinstance(mode, str) or mode.lower() not in self._supported_modes()
        ):
            if len(self._supported_modes()) == 1:
                msg = f"mode must be {self._supported_modes()[0]}"
            else:
                msg = (
                        "mode must be one of: " +
                        ", ".join(f"\"{mode}\"" for mode in self._supported_modes())
                )
            raise ValueError(msg)
        mode = mode.lower() if isinstance(mode, str) else mode
        self.mode = "numpy" if (numpy_seed or mode == "numpy") else "sequence"
        super().__init__(seed)
        if type(self) is BitGenerator:
            raise NotImplementedError(
                'BitGenerator is a base class and cannot be instantized'
            )

    def _supported_modes(self):
        return ("sequence",)

    def _get_seed_seq(self):
        try:
            return self.seed_seq
        except AttributeError:
            # Older versions of numpy have _seed_seq
            return self._seed_seq

    def _seed_from_seq(self):
        raise NotImplementedError("Subclass must override")

    def _seed_from_seq_numpy_compat(self):
        raise NotImplementedError("Subclass must override")

    cdef _copy_seed(self):
        import copy

        return copy.deepcopy(self._seed_seq)

    def _seed_with_seed_sequence(self, seed, **kwargs):
        if isinstance(seed, ISEED_SEQUENCES):
            self._seed_seq = seed
        else:
            self._seed_seq = SeedSequence(seed)
        if self.mode == "sequence":
            self._seed_from_seq(**kwargs)
        else:  # numpy
            self._seed_from_seq_numpy_compat(**kwargs)

    @property
    def state(self):
        raise NotImplemented("subclasses must implement")

    @state.setter
    def state(self, value):
        raise NotImplemented("subclasses must implement")

    def random_raw(self, size=None, output=True):
        """
        random_raw(size=None, output=True)

        Return randoms as generated by the underlying BitGenerator

        Parameters
        ----------
        size : int or tuple of ints, optional
            Output shape. If the given shape is, e.g., ``(m, n, k)``, then
            ``m * n * k`` samples are drawn. Default is None, in which case a
            single value is returned.
        output : bool, optional
            Output values. Used for performance testing since the generated
            values are not returned.

        Returns
        -------
        out : {uint64, ndarray, None}
            Drawn samples.

        Notes
        -----
        This method directly exposes the the raw underlying pseudo-random
        number generator. All values are returned as unsigned 64-bit
        values irrespective of the number of bits produced by the PRNG.

        See the class docstring for the number of bits returned.
        """
        return random_raw(&self._bitgen, self.lock, size, output)

    def _benchmark(self, Py_ssize_t cnt, method="uint64"):
        return benchmark(&self._bitgen, self.lock, cnt, method)

    @property
    def ctypes(self):
        """
        ctypes interface

        Returns
        -------
        interface : NamedTuple
            Named tuple containing ctypes wrapper

            * state_address - Memory address of the state struct
            * state - pointer to the state struct
            * next_uint64 - function pointer to produce 64 bit integers
            * next_uint32 - function pointer to produce 32 bit integers
            * next_double - function pointer to produce doubles
            * bit_generator - pointer to the bit generator struct
        """
        if self._ctypes is None:
            self._ctypes = prepare_ctypes(&self._bitgen)

        return self._ctypes

    @property
    def cffi(self):
        """
        CFFI interface

        Returns
        -------
        interface : NamedTuple
            Named tuple containing CFFI wrapper

            * state_address - Memory address of the state struct
            * state - pointer to the state struct
            * next_uint64 - function pointer to produce 64 bit integers
            * next_uint32 - function pointer to produce 32 bit integers
            * next_double - function pointer to produce doubles
            * bit_generator - pointer to the bit generator struct
        """
        if self._cffi is not None:
            return self._cffi
        self._cffi = prepare_cffi(&self._bitgen)
        return self._cffi

    @property
    def generator(self):
        """
        Removed, raises NotImplementedError
        """
        raise NotImplementedError("This method for accessing a Generator has"
                                  "been removed.")


cdef object benchmark(bitgen_t *bitgen, object lock, Py_ssize_t cnt, object method):
    """Benchmark command used by BitGenerator"""
    cdef Py_ssize_t i
    if method=="uint64":
        with lock, nogil:
            for i in range(cnt):
                bitgen.next_uint64(bitgen.state)
    elif method=="double":
        with lock, nogil:
            for i in range(cnt):
                bitgen.next_double(bitgen.state)
    else:
        raise ValueError("Unknown method")


cdef object random_raw(bitgen_t *bitgen, object lock, object size, object output):
    """
    random_raw(self, size=None)

    Return randoms as generated by the underlying PRNG

    Parameters
    ----------
    size : int or tuple of ints, optional
        Output shape. If the given shape is, e.g., ``(m, n, k)``, then
        ``m * n * k`` samples are drawn. Default is None, in which case a
        single value is returned.
    output : bool, optional
        Output values. Used for performance testing since the generated
        values are not returned.

    Returns
    -------
    out : uint or ndarray
        Drawn samples.

    Notes
    -----
    This method directly exposes the the raw underlying pseudo-random
    number generator. All values are returned as unsigned 64-bit
    values irrespective of the number of bits produced by the PRNG.

    See the class docstring for the number of bits returned.
    """
    cdef np.ndarray randoms
    cdef uint64_t *randoms_data
    cdef Py_ssize_t i, n

    if not output:
        if size is None:
            with lock:
                bitgen.next_raw(bitgen.state)
            return None
        n = np.asarray(size).sum()
        with lock, nogil:
            for i in range(n):
                bitgen.next_raw(bitgen.state)
        return None

    if size is None:
        with lock:
            return bitgen.next_raw(bitgen.state)

    randoms = <np.ndarray>np.empty(size, np.uint64)
    randoms_data = <uint64_t*>np.PyArray_DATA(randoms)
    n = np.PyArray_SIZE(randoms)

    with lock, nogil:
        for i in range(n):
            randoms_data[i] = bitgen.next_raw(bitgen.state)
    return randoms

cdef object prepare_cffi(bitgen_t *bitgen):
    """
    Bundles the interfaces to interact with a bit generator using cffi

    Parameters
    ----------
    bitgen : pointer
        A pointer to a bit generator instance

    Returns
    -------
    interface : NamedTuple
        The functions required to interface with the bit generator using cffi

        * state_address - Memory address of the state struct
        * state - pointer to the state struct
        * next_uint64 - function pointer to produce 64 bit integers
        * next_uint32 - function pointer to produce 32 bit integers
        * next_double - function pointer to produce doubles
        * bit_generator - pointer to the bit generator struct
    """
    try:
        import cffi
    except ImportError as exc:
        raise ImportError("cffi cannot be imported.") from exc

    ffi = cffi.FFI()
    _cffi = interface(<uintptr_t>bitgen.state,
                      ffi.cast("void *", <uintptr_t>bitgen.state),
                      ffi.cast("uint64_t (*)(void *)", <uintptr_t>bitgen.next_uint64),
                      ffi.cast("uint32_t (*)(void *)", <uintptr_t>bitgen.next_uint32),
                      ffi.cast("double (*)(void *)", <uintptr_t>bitgen.next_double),
                      ffi.cast("void *", <uintptr_t>bitgen))
    return _cffi

cdef object prepare_ctypes(bitgen_t *bitgen):
    """
    Bundles the interfaces to interact with a bit generator using ctypes

    Parameters
    ----------
    bitgen : pointer
        A pointer to a bit generator instance

    Returns
    -------
    interface : namedtuple
        The functions required to interface with the bit generator using ctypes:

        * state_address - Memory address of the state struct
        * state - pointer to the state struct
        * next_uint64 - function pointer to produce 64 bit integers
        * next_uint32 - function pointer to produce 32 bit integers
        * next_double - function pointer to produce doubles
        * bit_generator - pointer to the bit generator struct
    """
    import ctypes

    _ctypes = interface(<uintptr_t>bitgen.state,
                        ctypes.c_void_p(<uintptr_t>bitgen.state),
                        ctypes.cast(<uintptr_t>bitgen.next_uint64,
                                    ctypes.CFUNCTYPE(ctypes.c_uint64,
                                                     ctypes.c_void_p)),
                        ctypes.cast(<uintptr_t>bitgen.next_uint32,
                                    ctypes.CFUNCTYPE(ctypes.c_uint32,
                                                     ctypes.c_void_p)),
                        ctypes.cast(<uintptr_t>bitgen.next_double,
                                    ctypes.CFUNCTYPE(ctypes.c_double,
                                                     ctypes.c_void_p)),
                        ctypes.c_void_p(<uintptr_t>bitgen))
    return _ctypes

cpdef object object_to_int(object val, object bits, object name, int default_bits=64,
                           object allowed_sizes=(64,)):
    """
    Robustly convert any supported object to a non-negative Python integer

    Parameters
    ----------
    val : object
        Object to convert. Can be None.
    bits : int
        Number of bits in the returned object. Out-of-range values raise
        ValueError
    name : str
        Variable name for errors
    default_bits : int
        Either 32 or 64. Default type when converting non-arrays to arrays
    allowed_sizes : {(64,), (32,) (32, 64)}
        Allows bit sizes for the input

    Returns
    -------
    ival : {int, None}
        Python integer representation of value or None if val is None
    """
    if val is None:
        return None
    elif isinstance(val, (int, np.integer)):
        out = int(val)
    elif isinstance(val, np.ndarray):
        dtypes = []
        if 64 in allowed_sizes:
            dtypes.append(np.uint64)
        if 32 in allowed_sizes:
            dtypes.append(np.uint32)
        if val.dtype not in dtypes:
            all_sz = ",".join(map(str, allowed_sizes))
            raise TypeError("{0} arrays must be unsigned with a size in"
                            " {1}".format(name, all_sz))
    else:
        dtype = np.uint64 if default_bits==64 else np.uint32
        val = np.array(val)
        if not np.issubdtype(val.dtype, np.number):
            raise ValueError("{0} contains non-numeric values or values "
                             "out-of-range".format(name))
        if not np.all((val // 1) == val):
            raise TypeError("{0} contains floating point values".format(name))
        max_val = np.iinfo(dtype).max
        if not (np.all(val<=max_val) and np.all(val>=0)):
            raise ValueError("{0} has elements that are out-of-range for "
                             "{1}".format(name, str(dtype(0).dtype)))
        val = val.astype(dtype, casting="unsafe")
    if isinstance(val, np.ndarray):
        val = np.atleast_1d(val)
        if val.ndim != 1 or val.size == 0:
            raise ValueError("{0} must be 1-d and non-empty".format(name))
        power = 32 if val.dtype == np.uint32 else 64
        out = sum([int(val[i]) * 2**(power * i) for i in range(len(val))])
    if out < 0 or (bits is not None and out >= (int(2)**bits)):
        raise ValueError("{0} is out-of-range for "
                         "[0,2**{1})".format(name, bits))

    return out

cdef object wrap_int(object val, object bits):
    """Wraparound to place an integer into the interval [0, 2**bits)"""
    upper = int(2)**int(bits)
    if not 0<= val < upper:
        divisor = val // upper
        val = val - upper * divisor
    return val

cdef object check_state_array(object arr, np.npy_intp required_len,
                              int required_bits, object name):
    req_dtype = np.dtype("uint" + str(required_bits))
    if not isinstance(arr, np.ndarray):
        arr = np.array(arr, dtype=req_dtype)
    if arr.ndim != 1 or arr.dtype != req_dtype or arr.shape[0]!=required_len:
        raise ValueError("State element {0} must be a 1-d array with dtype {1} "
                         "and {2} elements".format(name, req_dtype,
                                                   required_len))
    return arr


cdef np.ndarray int_to_array(object value, object name, object bits, object uint_size):
    """
    Convert a large integer to an array of unsigned integers

    Parameters
    ----------
    value : int
        The value to convrt
    name : str
        Variable name to use in error messages
    bits : int
        Number of bits in value, e.g., 64, 128 or 256
    uint_size : int
        Number of bits of output array dtype, either 32 or 64

    Returns
    -------
    arr : np.ndarray
        1-d array of dtype np.uint{uint_size} containing value converted to
        fit the array dtype, where arr[0] is the lowest bits of value where
        arr[i] = (value >> (uint_size*i)) % 2**uint_size
    """
    req_len = bits // uint_size if bits is not None else None
    value = np.asarray(value, dtype=object)
    if uint_size == 32:
        dtype = np.uint32
    elif uint_size == 64:
        dtype = np.uint64
    else:
        raise ValueError("Unknown uint_size")
    if value.shape == ():
        orig = value
        value = int(value)
        if value != orig:
            raise TypeError("value must be an integer.")
        if bits is not None:
            upper = int(2)**int(bits)
            if value < 0 or value >= upper:
                raise ValueError("{name} must be positive and less than "
                                 "2**{bits}.".format(name=name, bits=bits))
        out = []
        while value:
            out.append(value % 2**int(uint_size))
            value >>= int(uint_size)
        if req_len is not None and len(out) < req_len:
            out.extend([0] * (req_len - len(out)))
        out = np.array(out, dtype=dtype)
    else:
        if not (np.all(value >= np.iinfo(dtype).min) and
                np.all(value <= np.iinfo(dtype).max)):
            raise ValueError("value is out of range for dtype "
                             "{0}".format(str(dtype)))
        out = value.astype(dtype, casting="unsafe")
        if req_len is not None and out.shape != (req_len,):
            raise ValueError("{name} must have {len} elements when using array"
                             " form".format(name=name, len=len))
    return out

cdef view_little_endian(arr, dtype):
    supported = (np.uint32, np.uint64)
    if dtype not in supported or arr.dtype not in supported:
        raise ValueError("Only support conversion between uint 32 and 64.")
    if arr.ndim != 1:
        raise ValueError("arr must be 1 dimensional")
    if arr.dtype == dtype or RANDOMGEN_LITTLE_ENDIAN:
        return arr.view(dtype)
    arr = arr.byteswap().view(dtype).byteswap()
    return arr

cdef byteswap_little_endian(arr):
    if RANDOMGEN_LITTLE_ENDIAN:
        return arr
    return arr.byteswap()

cdef uint64_t MAXSIZE = <uint64_t>sys.maxsize

cdef object fully_qualified_name(instance):
    """
    Return the module and class name

    Parameters
    ----------
    instance
        A bit generator instance

    Returns
    -------
    str
        The fully qualified name
    """
    typ = type(instance)
    return f"{typ.__module__}.{typ.__name__}"
